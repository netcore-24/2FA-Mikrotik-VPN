# Internationalization (i18n)

Documentation for the project's internationalization system.

## Overview

The project supports multiple languages for the UI and messages. Currently supported:
- Russian (ru) — default
- English (en)

## Language detection

The system determines the user's language in the following priority order:

1. **Query parameter** `?lang=ru` or `?lang=en`
2. **HTTP header** `Accept-Language` (e.g. `Accept-Language: ru-RU,ru;q=0.9,en;q=0.8`)
3. **Default setting** from the `LANGUAGE` environment variable or application settings

## API usage

### Dependency to get the language

Any endpoint can use dependencies to access the current language and translator:

```python
from backend.api.i18n_dependencies import get_language, get_translate

@router.get("/example")
async def example(
    language: str = Depends(get_language),
    t=Depends(get_translate),
):
    message = t("auth.login.title")
    return {"message": message, "language": language}
```

### Using translations

`t()` automatically uses the language derived from the request:

```python
# Simple translation
message = t("auth.login.title")

# Translation with parameters
message = t("validation.min_length", min_length=8)
```

## API endpoints

### GET /api/i18n/languages

Get the list of supported languages.

**Response:**

```json
{
  "supported_languages": ["ru", "en"],
  "default_language": "ru"
}
```

### GET /api/i18n/translations

Get all translations for the current language (auto-detected from the request).

**Query parameters:**
- `lang` (optional) — force language (e.g. `?lang=en`)

**Response:**

```json
{
  "language": "ru",
  "translations": {
    "auth": {
      "login": {
        "title": "Вход в систему",
        ...
      }
    },
    ...
  }
}
```

### GET /api/i18n/translate/{key}

Get translation for a specific key.

**Example:** `/api/i18n/translate/auth.login.title`

**Response:**

```json
{
  "key": "auth.login.title",
  "translation": "Login",
  "language": "en"
}
```

## Translation files structure

Translations are stored as JSON files under `locales/{language}/messages.json`:

```
locales/
├── ru/
│   └── messages.json
└── en/
    └── messages.json
```

### Key format

Translation keys use dot notation and nested objects:

```json
{
  "auth": {
    "login": {
      "title": "Login",
      "success": "Successfully logged in"
    }
  }
}
```

Usage: `t("auth.login.title")` → `"Login"`

### Parameters in translations

Parameters are supported via `{parameter_name}` placeholders:

```json
{
  "validation": {
    "min_length": "Minimum length: {min_length} characters"
  }
}
```

Usage: `t("validation.min_length", min_length=8)` → `"Minimum length: 8 characters"`

## Frontend usage

### Get all translations

```javascript
// On app initialization
const response = await fetch('/api/i18n/translations?lang=ru');
const { language, translations } = await response.json();

// Use
const message = translations.auth.login.title;
```

### Change language

```javascript
// Set language via query parameter
const response = await fetch('/api/i18n/translations?lang=en');
```

## Telegram bot usage

For the Telegram bot, language can come from user settings or fall back to default:

```python
from backend.utils.i18n import translate

# Explicit language
message = translate("telegram.bot.start", language="ru")

# Default language
message = translate("telegram.bot.start")
```

## Adding a new language

1. Create a directory for the new language:

```bash
mkdir -p locales/es  # e.g., Spanish
```

2. Copy the structure from an existing file:

```bash
cp locales/en/messages.json locales/es/messages.json
```

3. Translate the file contents

4. Add the language to the supported list:

```python
# backend/utils/i18n.py
SUPPORTED_LANGUAGES = ["ru", "en", "es"]
```

## Caching

Translations are cached in memory after the first load. To clear the cache:

```python
from backend.utils.i18n import clear_cache
clear_cache()
```

## Best practices

1. Use a hierarchical key structure
2. Use meaningful key names (`auth.login.title` is better than `msg1`)
3. Use parameters for dynamic values
4. Provide translations for all supported languages
5. Use a fallback (if a translation is missing, return the key)

